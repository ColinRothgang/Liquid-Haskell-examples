Macro-level translation design:
The translation translates:
- types 								-> types
- terms 								-> terms
- recursive definitions -> inductive definitions using Fixpoint or Equation and using proof-mode and 3rd "macro-tactic" if necessary
- (recursive) proofs 		-> ((nested) inductive) proofs (using Fixpoint or Equation induction principles)
- refinnement types 		-> subset types with membership proofs generated by the 3rd "macro-tactic" and with proof irrelevance principles back into them

Proofs are translated using the following 3 "macro-tactics" (possibly a tactic in Coq, maybe a function in the translation implementation):
1. a "macro-tactic" that translates recursive proofs into inductive proofs and takes as argments "macro-tactics" for the inductive subgoals
2. a "macro-tactic" that translates non-recursive proofs into non-inductive proofs
3. a "macro-tactic" that translates "trivial" proofs to non-inductive proofs and relies on heuristics, backtracking and, if necessary, SMTCoq and its extensions

Ad 1) Uses generalize dependents and (nested) induction if recursion is on inductive constructors, otherwise use induction principle generated based on termination metric in LH.
Use 2nd and 3rd "macro-tactics" to prove inductive sub-goals.

Ad 2) 
We need to translate ? and === combinators and utilize 3rd "macro-tactic" in between:
Translate ? using something rewrite, apply, replace, or similar or otherwise and assert proven using the hint to be used later
Translate === combinators to sequence of asserts, as well as (possibly) a rewrite or apply to the goal using the asserts
The steps resulting from those translation as consider to be the "hint-guided" steps in the proof.

Use representation of proof state (or actual proof state) and/or backtracking to determine how exactly to translate hints, when we are stuck and when to stop translating because the (sub)-goal is already proven.
When stuck try to:
A. Try to match on proof state to figure out problem and resolve it (using e.g. split, destructs, injection, ...) with lots of backtracking until next hint-guided step can be applied.
B. Rely on 3rd SMT solver tactic to simplify state until next hint-guided step can be applied (or (sub)-goal is proven)
C. Apply 3rd "macro-tactic" to solve remaining (sub)-goal

Ad 3)
works essentially the same way as 2nd "macro-tactic" when stuck between hint-guided steps



Differences between LH and Coq that cause translation challenges:

Big and hard problems:
1. LH uses recursion, Coq mostly induction
	- easy recursive functions 																																	-> inductive functions ("Fixpoints")
	- complicated recursive functions 																													-> Equations
	- function definition/proofs by recursion and matching on inductive constructors						-> inductive proofs, much simpler and preferable to Equations whenever possible
	- induction on several variables																														-> generalize dependents, followed by inductions, destructs in cases where needed, 
																																																 smt_app_ih tactic to move (and simplify) antecedents to assumptions before applying IH of (first) induction 
	- function definition/ by recursion not obviously mimicking induction, clearly terminating	-> ???, Fixpoints if possible, otherwise Equation guided by default termination metric
	- function definition/ by arbitrary recursion																								-> induction with Equations-generated induction principles using termination metrics, ???
2. simplification by smt vs. interactive approach in Coq																			-> better automation in custom tactics, Sniper, ???
3. LH ? combinator vs. tactics in Coq
	- arguments to ? in LH don't specify to what they are applied																-> smart custom tactics that infer the lacking info, good heuristics guided by conventions in LH, adding lemmas to be automatically used, backtracking
 	- LH specifies argument values for lemmas, Coq typically doesn't														-> allow tactics to take binder specifying values if needed, omit if can be inferred correctly
 	- LH simplifies proof state after each step																									-> need to simplify (and unify terms in assumptions???), betweeen proof steps
 	- adding superfluous hints is fine in LH, but adding extra steps in Coq isn't								-> doesn't seem possible to define if_not_done tactic in Coq, so need to somehow eliminate extra steps in Coq during translation
4. arguments to ? in LH are applied smartly accross assumptions and hypothesis								-> ???
5. Refinement types in function arguments in function definitions can be inferred only by LH	-> No obvious solution, within a function definitions we cannot apply the usual tactics (including snipe) to prove constraints
																																																 It might be necessary to translate such functions differently 
6. Proof irrelevance is required for working with subset types in Coq													-> This can hopefully be addressed via Coq custom tactics
 	
 Minor points:
- We should translate = on Booleans to <-> in Coq
- Rewriting via <-> (rather than =) requires setoid_rewrite


Further ideas:
- can translate LHS ? just === RHS to replace (LHS) (RHS); T(just). in Coq where T(just):=smt_apply_withn just (where n is number of arguments the head of just is applied to) is the translation of just in Coq
- translate (LHS  ? just === ... ? justn === RHS) ? ... to assert (eq: LHS = RHS); T(just); ...; T(justn); smt_app eq  in Coq ???
- modify smt_apply to rewrite/apply if possible, otherwise figure out arguments of lemma and add conclusion to context, to be used later

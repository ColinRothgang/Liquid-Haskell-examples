Macro-level translation design:
The translation translates:
- types 								-> types
- terms 								-> terms
- recursive definitions -> inductive definitions using Fixpoint or Equation and using proof-mode and 6th "macro-tactic" if necessary
- (recursive) proofs 		-> ((nested) inductive) proofs (using Fixpoint or Equation induction principles)
- refinnement types 		-> subset types with membership proofs generated by the 6th "macro-tactic" and with proof irrelevance principles back into them

Proofs are translated using the following 6 "macro-tactics" (either tactics in Coq or functions in the translation implementation):
1. a "macro-tactic" that translates recursive proofs into inductive proofs and takes as argments "macro-tactics" for the inductive subgoals
2. a "macro-tactic" that translates non-recursive proofs into non-inductive proofs
3. a "macro-tactic" that translates "trivial" proofs to non-inductive proofs and relies on heuristics, backtracking and, if necessary, SMTCoq and its extensions

Ad 1) Uses generalize dependents and (nested) induction if recursion is on inductive constructors, otherwise use induction principle generated based on termination metric in LH.
Use 5th and 6th "macro-tactics" to prove inductive sub-goals.

Ad 2) 
Translate ? using something rewrite, apply, replace, or similar.
The steps resulting from those tactics are considered to be the "hint-guided" steps in the proof.

Ad 3)
Translate === combinators to sequence of asserts proven using the hints given in LH for the === steps

Ad 4)
A tactic that translates a ? hint into an assert proven using the hint

Ad 5)
Use representation of proof state (or actual proof state) and/or backtracking to determine when to use 2nd resp. 3rd "macro-tactic" and when to stop translating because the (sub)-goal is already proven.

For each hint do the following:
- check if simplify proof state finishes (sub)-goal and if so do it and stop translating
- check if proof state can be simplified
	- if so try simplifying proof state and calling this "macro-tactic" on remaining hints
		- if succesful do it and stop translating
		- otherwise do nothing and continue
- Try to solve the goal with 6th "macro-tactic" and if sucessful do it and stop translating (ignoring all further hints)
- translate ? hint using 2nd "macro-tactic" if possible, if yes
	- if we are done afterwards apply that "macro-tactic" and stop translating further
	- if we are not done afterwards try applying that "macro-tactic" followed by this "macro-tactic" applied to remaining hints
		- if succesful apply that rewrite, apply or similar "macro-tactic" and continue loop
		- otherwise use 3nd "macro-tactic" to asserts result of hint and continue loop (we cannot be done yet with (sub)-goal)
- translate === as sequences of asserts using 4nd "macro-tactic" and 
	- check if we can rewrite/apply, ... with the asserted hypothesis
		- if so do it and if that finishes goal stop translating further

After having translated all hints (and not yet having solved (sub)-goal) apply 6th "macro-tactic" to use generated hypothesis to solve the remaining (sub)-goal

Ad 6)
Repeat the following two steps until (sub)-goal is solved:
A. Try to match on proof state to figure out a problem that prevents automatically solving goal and resolve it (using e.g. split, destructs, injection, ...) with lots of backtracking
B. Use SMT solver tactic to solve or simplify remaining goal


Differences between LH and Coq that cause translation challenges:

Big and hard problems:
1. LH uses recursion, Coq mostly induction
	- easy recursive functions 																																	-> inductive functions ("Fixpoints")
	- complicated recursive functions 																													-> Equations
	- function definition/proofs by recursion and matching on inductive constructors						-> inductive proofs, much simpler and preferable to Equations whenever possible
	- induction on several variables																														-> generalize dependents, followed by inductions, destructs in cases where needed, 
																																																 smt_app_ih tactic to move (and simplify) antecedents to assumptions before applying IH of (first) induction 
	- function definition/ by recursion not obviously mimicking induction, clearly terminating	-> ???, Fixpoints if possible, otherwise Equation guided by default termination metric
	- function definition/ by arbitrary recursion																								-> induction with Equations-generated induction principles using termination metrics, ???
2. simplification by smt vs. interactive approach in Coq																			-> better automation in custom tactics, Sniper, ???
3. LH ? combinator vs. tactics in Coq
	- arguments to ? in LH don't specify to what they are applied																-> smart custom tactics that infer the lacking info, good heuristics guided by conventions in LH, adding lemmas to be automatically used, backtracking
 	- LH specifies argument values for lemmas, Coq typically doesn't														-> allow tactics to take binder specifying values if needed, omit if can be inferred correctly
 	- LH simplifies proof state after each step																									-> need to simplify (and unify terms in assumptions???), betweeen proof steps
 	- adding superfluous hints is fine in LH, but adding extra steps in Coq isn't								-> doesn't seem possible to define if_not_done tactic in Coq, so need to somehow eliminate extra steps in Coq during translation
4. arguments to ? in LH are applied smartly accross assumptions and hypothesis								-> ???
5. Refinement types in function arguments in function definitions can be inferred only by LH	-> No obvious solution, within a function definitions we cannot apply the usual tactics (including snipe) to prove constraints
																																																 It might be necessary to translate such functions differently 
6. Proof irrelevance is required for working with subset types in Coq													-> This can hopefully be addressed via Coq custom tactics
 	
 Minor points:
- We should translate = on Booleans to <-> in Coq
- Rewriting via <-> (rather than =) requires setoid_rewrite


Further ideas:
- can translate LHS ? just === RHS to replace (LHS) (RHS); T(just). in Coq where T(just):=smt_apply_withn just (where n is number of arguments the head of just is applied to) is the translation of just in Coq
- translate (LHS  ? just === ... ? justn === RHS) ? ... to assert (eq: LHS = RHS); T(just); ...; T(justn); smt_app eq  in Coq ???
- modify smt_apply to rewrite/apply if possible, otherwise figure out arguments of lemma and add conclusion to context, to be used later
